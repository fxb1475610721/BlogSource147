---
title: UML图详解（八）状态机（状态图和活动图） 
date: 2016-06-15 13:56:52
categories:
	- UML建模
tags:
	- UML
	- 状态机
	- 状态图
	- 活动图
---

# 一、概念

**状态图和活动图是状态机的两种表现形式。**利用状态机可以精确地描述对象的行为。

从对象的初始状态起，开始响应事件并执行某些动作，这些事件引起状态的转换；对象在新状态下又开始响应事件和执行动作，如此连续进行直到终结状态。

# 二、状态图

状态图\(State Diagram\) =状态\(State\) + 迁移\(Transition\)

* 一个状态图描述一个状态机。
* 状态图表现从一个状态到另一个状态的控制流。

## 2.1 状态图的语法

* 除了状态中的**初始状态（实心圆）和终止状态（牛眼形状）**，其它状态用一个圆角矩形表示
* 转换表示状态间可能的路径，用箭头表示
* 事件/动作写在由它们触发引起的转换上

![](http://img.blog.csdn.net/20160616081124428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 2.2 状态

* 状态一般是给定类对象中的一组属性值，在其所在的上下文中应该唯一，但可以匿名。
* 在对系统建模时，我们可以只关心那些明显影响对象行为的属性以及由他们表达的对象状态，而不用理睬那些于对象行为无关的状态。

表示方式：状态由一个带圆角的矩形表示。

![](http://img.blog.csdn.net/20160616082444746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**应用标签标示状态的内部活动。**

**语法：**标签/活动表达式

**UML提供的标签：**

1. entry：当进入一个状态的时候被自动触发，该活动在状态中其它任何活动之前被自动触发。
2. do：当状态处于激活时执行do活动，do活动在进入活动之后执行，并且一直运行到它本身完成为止。
3. exit：当离开一个状态的时候被自动触发，该活动在该状态结束之前、所有其它活动都完成后被触发。

&#8195;&#8195;**状态可以嵌套状态图，此时状态称为组成状态，否则为简单状态。**
&#8195;&#8195;入口事件表示一个入口的动作序列，它在进入状态时执行。入口事件的动作是原子的，并且先于人和内部活动或转换。
&#8195;&#8195;出口事件表示一个出口的动作序列，它在退出状态时执行。出口事件也是原子的，它跟在所有的内部活动之后，但是先于所有的出口转换。

**1. 简单状态（Simple State）**

![](http://img.blog.csdn.net/20160616084807934?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**

**2. 复合状态（Composite State）**

![](http://img.blog.csdn.net/20160616084934849?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**复合状态可以有多组状态图，每组用虚线分割开来。**

* 可以是通过“或”关系分解为互相排斥的**顺序子状态**
* 可以是使用“与”关系分解为**并发子状态**

* 如果一个组成状态的子状态对应的对象在其生命期内的任何时刻都只能处于一个子状态，即多个子状态之间是互斥的，不能同时存在，这种子状态称为顺序子状态。

* 并发子状态在同一层次给出两个或多个顺序子状态，任何时刻对象的状态是其每个并发段中任取一个状态的组合。

* 并发状态图由两个或多个并发子图组成，每个子图叫作一个并发段。在任何时刻，一个对象的状态是每个并发段中各取一个状态的组合。当对象离开并发段后，它又恢复成一个单一的状态。

* 如果并发子图中的一个状态首先完成，它将首先转入下一个状态。但是，如果异常事件发生，则进入唯一的异常状态。

* 当一个对象有几个相互独立的行为时，并发状态图可以方便地刻画它的行为。但一个对象的并发行为不应太多；如果太多，应将其状态图分细。

并发区域（Concurrent Regions）

&#8195;&#8195;状态图可以分为区域，而区域又包括退出或者当前执行的子状态。说明组合状态在某一时刻可以同时达到多个子状态。如下图刹车系统，同时进入前刹车【Applying Front Brakes】状态和后刹车【Applying Rear Brakes】状态。

![](http://img.blog.csdn.net/20160616093216218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**3. 初始状态（Initial State）**

* 初始状态代表状态图的起始位置，**只能作为转换的源**
* **初始状态在一个状态图中只允许有一个**，而不能作为转换的目标。，它用一个实心的圆表示。

![](http://img.blog.csdn.net/20160616085042584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**

**4. 终止状态（Final State）**

* 终止状态是模型元素的最后状态，是一个状态图的终止点。
* 终止状态只能作为转换的目标，而不能作为转换的源。
* 终止状态在一个状态图中可以有多个，它用一个套有一个实心圆的空心圆表示。

![](http://img.blog.csdn.net/20160616085116485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)**
**

**5. 结合状态（Junction State）---《暂时未理解》**

将两个转换连接成一次就可以完成的转换。** **

**6. 历史状态（History State）**

保存组成状态中先前被激活的状态

![](http://img.blog.csdn.net/20160616085354992?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

* 历史状态代表上次离开组成状态时的最后一个活动子状态，它用一个包含字母“H”的小圆圈表示。
* 每当转换到组成状态的历史状态时，对象便恢复到上次离开该组成状态时的最后一个活动子状态，并执行入口动作。

&#8195;&#8195;历史状态是一个伪状态（Pseudostate）,其目的是记住从组合状态中退出时所处的子状态，当再次进入组合状态，可直接进入这个子状态，而不是再次从组合状态的初态开始。

![](http://img.blog.csdn.net/20160616092548210?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在上图的状态图中，正常的状态顺序是:【Washing】→【Rinsing】→【Spinning】。
如果是从状态【Rinsing】突然停电（Power Cut）退出，,洗衣机停止工作进入状态【Power Off】，当电力恢复时直接进入状态【Running】。

**7.退出节点（Exit Point）**

![](http://img.blog.csdn.net/20160616093012529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 2.3 判定

判定在状态图中的位置：工作流在此处按监护条件的取值而发生分支。
表示方式：判定用空心小菱形表示。

![](http://img.blog.csdn.net/20160616081754534?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 2.4 迁移/转移（Transitions）

&#8195;&#8195;转移（Transitions）是两个状态之间的一种关系，表示对象将在源状态（Source State）中执行一定的动作，并在某个特定事件发生而且某个特定的警界条件满足时进入目标状态（Target State）

![](http://img.blog.csdn.net/20160616130313683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

事件标记（Trigger）：是转移的诱因，可以是一个信号，事件、条件变化（a change in some condition）和时间表达式。

警界条件（Guard Condition）：当警界条件满足时，事件才会引发转移（Transition）。

结果（Effect）：对象状态转移后的结果。

## 2.5 动作（State Actions）

&#8195;&#8195;动作（Actions）是一个可执行的原子操作,也就是说动作是不可中断的，其执行时间是可忽略不计的。UML提供的三中标签《参考上面》

&#8195;&#8195;在上例中，对象状态转移后的结果显示在转移线上，如果目标状态有许多转移，而且每个转移有相同的结果，这时把转移后的结果（Effect）展示在目标状态中（Target State）更好一些，可以定义进入动作（Entry Action ）和退出动作（Exit Action），如下图

![](http://img.blog.csdn.net/20160616093748588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

# 三、活动图

&#8195;&#8195;活动图\(Activity Diagram\) = 活动\(Activity\) + 动作\(Action\) + 活动边\(Activity Edge\) + 活动节点\(Activity Node\)

* 活动图是状态机的另一种表现形式。用于为一个对象在其生命周期中的行为建模。
* 活动图是一种描述系统动态行为的图，它用于描述活动的顺序，展现从一个活动到另一个活动的控制流。

## 3.1 动作状态

* 动作状态是指执行原子的、不可中断的动作，并在此动作完成后通过转换转向另一个动作。
* 动作状态使用平滑的圆角矩形表示，动作状态所表示的动作写在圆角矩形内部。

![](http://img.blog.csdn.net/20160617150545350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**动作状态的特点：**

1. 动作状态是原子的，它是构造活动图的最小单位，已经无法分解为更小的部分。
2. 动作状态是不可中断的状态，它一旦开始运行就不能中断，一直运行到结束。
3. 动作状态是瞬时的行为，它所占用的处理事件极短，有时甚至可以忽略。
4. 动作状态和状态图中的状态不同，它不能有入口动作和出口动作，更不能有内部转移。

## 3.2 活动状态

* 活动状态用于表达状态机中的一个非原子的运行。
* 活动状态的表示图标也是平滑的圆角矩形，并可以在图标中给出入口动作和出口动作等信息。

![](http://img.blog.csdn.net/20160617150932611?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
**活动状态的特点：**

1. 活动状态可以分解成其他子活动或动作状态，由于它是一组动作或操作的组合，所以可以被中断。
2. 活动状态的内部活动可以用另一个活动图来表示。
3. 和动作状态不同，活动状态可以有入口动作和出口动作，也可以有内部转移。
4. 动作状态是活动状态的一个特例，如果某个活动状态只包括一个动作，那么它就是一个动作状态。

## 3.3 动作流

* 所有动作状态之间的转换流称之为动作流，相当于状态图中的转换。
* **与状态图的转换相同，活动图的转换也用带箭头的直线表示，箭头的方向指向转入的方向。**
* 动作流可以是无条件的，也可以是有条件的。无条件的动作流即是活动图中的普通转换（完成转换，内部转换）；有条件的动作流通过分支与合并来描述。

## 3.4 分支与合并

* 条件行为用分支和合并表达。
* **在活动图中分支与合并用空心小菱形表示。**
* 一个分支有一个入转换和两个带条件的出转换，出转换的条件应当是互斥的，这样可以保证只有一条出转换能够被触发。
* 一个合并有两个带条件的入转换和一个出转换，合并表示从对应的分支开始的条件行为的结束。

![](http://img.blog.csdn.net/20160617151616146?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 3.5 分叉与汇合（并发与同步）

1. 分叉用于将动作流分为两个或者多个并发运行的分支，而汇合则用于同步这些并发分支，以达到共同完成一项事务的目的。
2. 分叉可以用来描述并发线程，每个分叉可以有一个输入转换和两个或多个输出转换，每个转换都可以是独立的控制流。
3. 汇合代表两个或多个并发控制流同步发生，当所有的控制流都达到汇合点后，控制才能继续往下进行。每个汇合可以有两个或多个输入转换和一个输出转换。
4. 分叉和汇合都使用加粗的水平线段表示。

![](http://img.blog.csdn.net/20160617151834022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![](http://img.blog.csdn.net/20160617152138351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 3.6 泳道

1. 泳道将活动图中的活动化分为若干组，并把每一组指定给负责这组活动的业务组织即对象。
2. 泳道区分了负责活动的对象，明确地表示了哪些活动是由哪些对象进行的。
3. 每个活动只能明确地属于一个泳道。
4. 泳道用垂直实线绘出，垂直线分隔的区域就是泳道。在泳道上方可以给出泳道的名字或对象（对象类）的名字，该对象（对象类）负责泳道内的全部活动。
5. 泳道没有顺序，不同泳道中的活动既可以顺序进行也可以并发进行，动作流和对象流允许穿越分隔线。

![](http://img.blog.csdn.net/20160617152551650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 3.7 对象流

&#8195;&#8195;对象流是动作状态或者活动状态与对象之间的依赖关系，表示动作使用对象或者动作对对象的影响。

**对象流中的对象特点：**

1. 一个对象可以由多个动作操纵。
2. 一个动作输出的对象可以作为另一个动作输入的对象。
3. 在活动图中，同一个对象可以多次出现，它的每一次出现表明该对象正处于对象生存期的不同时间点。

**对象流用带有箭头的虚线表示。如果箭头从动作状态出发指向对象，则表示动作对对象施加了一定的影响。**如果箭头从对象指向动作状态，则表示该动作使用对象。

![](http://img.blog.csdn.net/20160617152551650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 3.8 活动的分解

1. 一个活动可以分为若干个动作或子活动，这些动作和子活动本身可以组成一个活动图。
2. 一个包含子活动的活动和嵌套了子状态的组合状态类似，概念上也相对统一。
3. 一个不含内嵌活动或动作的活动称之为简单活动；一个嵌套了若干活动或动作的活动称之为组合活动，组合活动有自己的名字和相应的子活动图。

![](http://img.blog.csdn.net/20160617153121963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

# 四、活动图与状态图的区别

1. 活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。一般是一个结束后，自动转入下一个活动。
2. 状态图着重描述从一个状态到另一个状态的流程，主要有外部事件的参与。
3. 活动图是一种特殊的状态图，如果在一个状态图中的大多数状态是表示操作的活动，而转移是由状态中动作的完成来触发，即全部或绝大多数的事件是内部产生的动作完成的，这就是活动图。

# 五、活动图与流程图的区别

1. **流程图着重描述处理过程**，它的主要控制结构是顺序、分支和循环，各个处理之间有严格的顺序和时间关系；而活动图描述的则是对象活动的顺序关系所遵循的规则，它着重表现的是系统的行为，而非系统的处理过程。
2. **活动图能够表示并发活动的情形**，此时活动图给了我们选择做事顺序的自由，而**流程图对活动顺序的描述固定。**
3. 活动图是面向对象的，流程图是面向过程的。

# 六、活动图应用

活动图的优缺点：

* 优点：最适合支持并行行为，而且也是支持多线程编程的有力工具。
* 缺点：很难清楚地描述动作与对象之间的关系。虽然在活动旁标出对象名或者采用泳道技术可以定义这种关系，但仍然没有交互图简单直接。

因此，像大多数建模技术一样，最好把活动图与其他技术结合使用。

## 6.1 何时可使用活动图

1. 分析用例。能直观清晰地分析用例，了解应当采取哪些动作以及这些动作之间的依赖关系。一张完整的活动图是所有用例的集成图。
2. 理解牵涉多个用例的工作流。在难于区分不同用例而对整个系统的工作过程又十分清楚时，可以先构造活动图，然后用切片技术派生用例图。
3. 处理多线程应用。采用“分层抽象，逐步细化”的原则描述多线程。

## 6.2 何时不应使用活动图

1. 显示对象间的合作。用交互图显示对象间的合作更简单直观。
2. 显示对象在生命周期内的运转情况。活动图可以表示活动的激活条件，但不能表示一个对象的状态变换条件。因此，当要描述一个对象整个生命周期的运转情况时，应当使用状态图。

## 6.3 建模的一般步骤

1. 识别要对其工作流描述的类或对象。
2. 确定工作流的初始状态和终止状态，明确工作流的边界。
3. 对动作状态或活动状态建模。
4. 对动作流建模。
5. 对对象流建模。
6. 对建立的模型进行精化和细化。

>博文编号：20160615135652
